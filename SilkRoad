import java.util.Scanner; // Para recibir la longitud desde el usuario
import java.util.List;
import java.util.*;

/**
 * SilkRoad modela un camino (Road) sobre el cual se colocan tiendas (Store) y robots (Robot).
 * Administra:
 * <ul>
 *   <li>Colocación, movimiento y retorno de robots.</li>
 *   <li>Colocación de tiendas y transferencia de tenges al coincidir con robots.</li>
 *   <li>Cálculo de la ganancia total (profit) y acumulada por ubicación (profitPerLocation).</li>
 *   <li>Modo "día" (dayMode): reboot() avanza eventos de un schedule sin limpiar el estado acumulado.</li>
 * </ul>
 * Estructuras principales:
 * <ul>
 *   <li>stores / robots: matrices de datos básicos.</li>
 *   <li>storeRefs / robotRefs: referencias a objetos gráficos.</li>
 *   <li>profitPerLocation: acumulado de lo recogido por celda.</li>
 * </ul>
 */
public class SilkRoad {
    private int length;                 // Longitud de la SilkRoad
    private int[][] stores;             // Matriz de tiendas {location, tenges}
    private int[][] robots;             // Matriz de robots {location, tenges}
    private int[][] positions;
    private Road road;
    private int profit;
    private boolean lastOperationOK;
    private ProgressBar progressBar;
    private boolean visible;
    private int maxProfit;
    private int tenges;
    private Robot[] robotRefs; 
    private Store[] storeRefs;
    private int[] robotOrigins;
    private int[][] profitPerLocation;
    
    private int[][] daysSchedule = null;   // cada evento: [1,x] robot, [2,x,c] tienda
    private int dayIndexSchedule = -1;     // -1 = no se ha aplicado ningún día
    private boolean dayMode = false;       // true => reboot actúa como "pasar día"

    /**
     * Crea una SilkRoad con un número de celdas.
     * @param length longitud lógica (se usa length+1 internamente para matrices)
     */
    public SilkRoad(int length ) {
        this.length = length;
        this.positions = new int[length+1][2];
        this.stores = new int[length+1][2];     
        this.robots = new int[length+1][2];
        this.robotRefs = new Robot[this.positions.length];
        this.storeRefs = new Store[this.positions.length];
        this.robotOrigins = new int[length+1];
        Arrays.fill(this.robotOrigins, -1);
        this.road = new Road(length);
        this.profitPerLocation = new int[this.positions.length+1][2];
        for (int i = 0; i < this.profitPerLocation.length; i++) {
            this.profitPerLocation[i][0] = i;   // location
            this.profitPerLocation[i][1] = 0;   // acumulado
        }
        int[][] roadPos = road.getPositions();
        for (int i = 0; i < roadPos.length; i++) {
            this.positions[i][0] = roadPos[i][0];
            this.positions[i][1] = roadPos[i][1];
        }
        this.progressBar = new ProgressBar(true);        
        this.profit = 0;        
        this.maxProfit = 0;
        this.visible = true;
        this.lastOperationOK = true;
    }
    
    /**
     * Constructor que recibe un schedule de días (eventos).
     * No coloca nada al inicio; se avanza usando reboot() en modo día.
     * @param days matriz de eventos: [1,x] = robot en x, [2,x,c] = tienda en x con c tenges
     */
    public SilkRoad(int[][] days) {
        this(Math.max(231, maxLocationFromDays(days))); // this(...) debe ir primero
        this.daysSchedule = days;
        this.dayIndexSchedule = -1;
        this.dayMode = true;
        System.out.println("Schedule cargado: " + (days == null ? 0 : days.length) + " días. Usa reboot() para pasar el día.");
    }

    /**
     * @return longitud lógica configurada para el camino.
     */
    public int getLength() {
        return length;
    }

    /**
     * Devuelve la matriz interna de robots (uso interno).
     * @return matriz robots con pares {location, tenges}.
     */
    private int[][] getRobots() {
        return robots;
    }
    
    /**
     * Ordena la matriz de tiendas por ubicación (no modifica referencias storeRefs).
     * (Uso potencial para listados externos.)
     */
    private void sortStores() {
        Arrays.sort(stores, (a, b) -> Integer.compare(a[0], b[0]));  // Ordena por la columna de location
    }

    /**
     * Ordena la matriz de robots por ubicación (no modifica robotRefs).
     */
    private void sortRobots() {
        Arrays.sort(robots, (a, b) -> Integer.compare(a[0], b[0]));  // Ordena por la columna de location
    }
    
    /**
     * Retorna el acumulado de profit por ubicación (>0).
     * @return matriz de pares [location, acumulado].
     */
    public int[][] profitPerMove() {
        List<int[]> result = new ArrayList<>();
        for (int i = 0; i < profitPerLocation.length; i++) {
            if (profitPerLocation[i][1] > 0) {
                result.add(new int[]{ profitPerLocation[i][0], profitPerLocation[i][1] });
            }
        }
        return result.toArray(new int[0][0]);
    }

    /**
     * Establece manualmente posición (x,y) de una celda.
     * @param index índice de la celda
     * @param x coordenada X
     * @param y coordenada Y
     */
    public void setCellPosition(int index, int x, int y) {
        if (index >= 0 && index < positions.length) {
            positions[index][0] = x;
            positions[index][1] = y;
        }
    }

    /**
     * Coloca una tienda si la casilla está libre.
     * Aumenta maxProfit y actualiza la barra de progreso.
     * Si hay un robot ya presente, se transfiere el dinero inmediatamente.
     * @param location índice de la celda
     * @param tenges cantidad de tenges inicial
     */
    public void placeStore(int location, int tenges) {
        if (location < 0 || location >= positions.length) {
            System.out.println("Índice de casilla inválido: " + location);
            return;
        }
        if (storeRefs[location] != null) {
            System.out.println("Ya existe una tienda en la casilla " + location);
            return;
        }
    
        // crear y registrar la tienda
        Store s = new Store(this.visible);
        storeRefs[location] = s;
    
        // guardar datos en la matriz de stores
        stores[location][0] = location;  
        stores[location][1] = tenges;
        maxProfit += tenges;
        updateProgressBar();
        
        if (this.visible && road != null) {
            road.assignStore(s);
            road.assignObjectPosition(location, "store");
            s.makeVisible();
        }
        transferTengesIfCoincide();
        System.out.println("Tienda colocada en la casilla " + location + " con " + tenges + " tenges.");
        lastOperationOK = true;
    }
    
    /**
     * Lista las tiendas vaciadas (tenges=0) que tenían objeto Store asociado.
     * Cambia el color visual de dichas tiendas a negro.
     * @return matriz [n][2] con {location, 0}
     */
    public int[][] emptiedStores() {
        // Lista temporal para guardar las tiendas vacías
        List<int[]> emptyList = new ArrayList<>();
    
        for (int i = 0; i < stores.length; i++) {
            if (storeRefs[i] != null && stores[i][1] == 0) { 
                // Cambiar el color de la tienda a negro
                storeRefs[i].changeColor("black");
    
                // Guardar datos de la tienda vacía en formato [location, tenges]
                emptyList.add(new int[]{i, 0});
            }
        }
    
        // Ordenamos por la ubicación (location)
        emptyList.sort(Comparator.comparingInt(a -> a[0]));
    
        // Convertimos la lista a matriz
        int[][] result = new int[emptyList.size()][2];
        for (int j = 0; j < emptyList.size(); j++) {
            result[j][0] = emptyList.get(j)[0]; // location
            result[j][1] = emptyList.get(j)[1]; // tenges (0)
        }
    
        return result;
    }

    /**
     * Coloca un robot en la ubicación dada si está libre.
     * Si hay una tienda con tenges se transfiere inmediatamente.
     * @param location índice de la celda
     */
    public void placeRobot(int location) {
        if (location < 0 || location >= positions.length) {
            System.out.println("Índice de casilla inválido: " + location);
            return;
        }
        if (robotRefs[location] != null) {
            System.out.println("Ya existe un robot en la casilla " + location);
            return;
        }
    
        // crear y registrar el robot (solo aquí)
        Robot r = new Robot(this.visible);
        robotRefs[location] = r;
    
        // actualizar la matriz de robots (si la usas para llevar info)
        robots[location][0] = location;
        robots[location][1] = 0; // tenges iniciales
        robotOrigins[location] = location;
    
        if (this.visible && road != null) {
            road.assignRobot(r);
            road.assignObjectPosition(location, "robot");
            r.makeVisible();
        }
    
        System.out.println("Robot colocado en la casilla " + location);
        transferTengesIfCoincide();
        lastOperationOK = true;
    }

    /**
     * Mueve un robot existente a una nueva posición (location+meters).
     * @param location posición actual del robot
     * @param meters desplazamiento (positivo o negativo)
     */
    public void moveRobot(int location, int meters) {
        if (location < 0 || location >= robotRefs.length) {
            System.out.println("Índice origen inválido: " + location);
            return;
        }
        Robot r = robotRefs[location];
        if (r == null) {
            System.out.println("No hay robot en la casilla " + location);
            return;
        }
        int newLocation = location + meters;
        if (newLocation < 0 || newLocation >= robotRefs.length) {
            System.out.println("Movimiento inválido: fuera de límites.");
            return;
        }
        if (robotRefs[newLocation] != null) {
            System.out.println("Ya existe un robot en la casilla destino " + newLocation);
            return;
        }
        int tenges = robots[location][1];
        int originVal = robotOrigins[location];
        if (originVal == -1){
            originVal = location;
        }
        robotRefs[location] = null;
        robots[location][0] = 0;
        robots[location][1] = 0;
        robotRefs[newLocation] = r;
        robots[newLocation][0] = newLocation;
        robots[newLocation][1] = tenges;
        robotOrigins[newLocation] = originVal;
        
        if (this.visible && road != null) {
            road.assignRobot(r); // por seguridad, aseguramos que road conozca la instancia
            road.moveRobotVisual(location, meters, r);
        }
        
        System.out.println("Robot movido de la casilla " + location + " a la casilla " + newLocation);
        transferTengesIfCoincide();
        lastOperationOK = true;
    }
    
    /**
     * Busca el par robot-tienda con menor distancia y mueve ese robot a la tienda.
     * Si no hay combinación válida, no hace nada.
     */
    public void moveRobots() {
        int closestRobot = -1;
        int closestStore = -1;
        int minDistance = Integer.MAX_VALUE;
    
        // Buscar la tienda más cercana para cada robot
        for (int s = 0; s < stores.length; s++) {
            if (storeRefs[s] != null && stores[s][1] > 0) {  // tienda activa con tenges
                for (int r = 0; r < robots.length; r++) {
                    if (robotRefs[r] != null) {  // robot existente
                        int distance = Math.abs(r - s);
                        if (distance < minDistance) {
                            minDistance = distance;
                            closestRobot = r;
                            closestStore = s;
                        }
                    }
                }
            }
        }
    
        if (closestRobot == -1 || closestStore == -1) {
            System.out.println("moveRobots: No hay robots o tiendas activas.");
            return;
        }
    
        // Calcular el movimiento en "meters" (diferencia de celdas)
        int meters = closestStore - closestRobot;
    
        System.out.println("moveRobots: Robot en " + closestRobot + 
                           " irá a tienda en " + closestStore + 
                           " -> meters=" + meters);
    
        // Mover el robot usando tu método que ya maneja la parte gráfica
        moveRobot(closestRobot, meters);
    
        lastOperationOK = true;
    }

    /**
     * Reabastece todas las tiendas existentes a 10 tenges (si tienen menos).
     */
    public void resupplyStores() {        
        // Reabastece todas las tiendas a 10 tenges (o el valor que desees)        
        for (int i = 0; i < stores.length; i++) {            
            if (storeRefs[i] != null) {       
                int diff = 10 - stores[i][1];                
                if (diff > 0) {                    
                    stores[i][1] = 10;                    
                    maxProfit += diff;                
                }            
            }        
        }        
        updateProgressBar();        
        System.out.println("Tiendas reabastecidas.");        
        lastOperationOK = true;    
    }

    /**
     * Devuelve robots a su posición original (si fue registrada).
     */
    public void returnRobots() {
        for (int i = 0; i < robotRefs.length; i++) {
            Robot r = robotRefs[i];
            if (r == null) continue;
    
            int originIndex = robotOrigins[i];
            if (originIndex == -1 || originIndex == i) continue;
    
            int tenges = robots[i][1];
    
            // liberar casilla actual
            robotRefs[i] = null;
            robots[i][0] = 0;
            robots[i][1] = 0;
            robotOrigins[i] = -1;
    
            // devolver al origen
            robotRefs[originIndex] = r;
            robots[originIndex][0] = originIndex;
            robots[originIndex][1] = tenges;
            robotOrigins[originIndex] = originIndex;
    
            // mover visual
            
            if (this.visible && road != null) {
                road.moveRobotVisual(i, originIndex, r);
            }
            
    
            System.out.println("Robot devuelto de " + i + " a su posición original " + originIndex);
            lastOperationOK = true;
        }
    }

    /**
     * Hace invisible todos los elementos gráficos (sin limpiar datos).
     */
    public void makeInvisible() {
        if (!visible) {
            System.out.println("SilkRoad: ya estaba invisible.");
            return;
        }
    
        // Ocultar tiendas
        if (storeRefs != null) {
            for (Store s : storeRefs) {
                if (s != null) s.makeInvisible();
            }
        }
    
        // Ocultar robots
        if (robotRefs != null) {
            for (Robot r : robotRefs) {
                if (r != null) r.makeInvisible();
            }
        }
    
        // Ocultar camino y barra
        if (road != null) road.makeInvisible();
        if (progressBar != null) progressBar.makeInvisible();
    
        visible = false;
        System.out.println("SilkRoad: ahora invisible (estado guardado, lógica activa).");
    }
    
    /**
     * Restituye visibilidad de todos los elementos todavía existentes.
     */
    public void makeVisible() {
        if (visible) {
            System.out.println("SilkRoad: ya estaba visible, no se hace nada.");
            return;
        }
    
        // Mostrar camino
        if (road != null) road.makeVisible();
    
        // Mostrar tiendas en su última posición
        if (storeRefs != null) {
            for (int i = 0; i < storeRefs.length; i++) {
                Store s = storeRefs[i];
                if (s != null) {
                    s.makeVisible(); // usa posición actual (ya guardada en Store)
                }
            }
        }
    
        // Mostrar robots en su última posición
        if (robotRefs != null) {
            for (int i = 0; i < robotRefs.length; i++) {
                Robot r = robotRefs[i];
                if (r != null) {
                    r.makeVisible(); // usa la posición actual (ya guardada en Robot)
                }
            }
        }
    
        if (progressBar != null) progressBar.makeVisible();
    
        visible = true;
        System.out.println("SilkRoad: ahora visible (manteniendo posiciones actuales).");
    }

    /**
     * Reinicia el estado:
     * <ul>
     *   <li>En dayMode: aplica siguiente evento del schedule sin limpiar.</li>
     *   <li>Modo normal: limpia robots, tiendas y reinicia profit.</li>
     * </ul>
     */
    public void reboot() {
        // MODO DÍAS: si hay schedule activo, reboot avanza el día y NO borra nada
        if (dayMode && daysSchedule != null) {
            if (dayIndexSchedule + 1 >= daysSchedule.length) {
                System.out.println("No hay más días en el schedule.");
                lastOperationOK = true;
                return;
            }
            dayIndexSchedule++;
            int[] e = daysSchedule[dayIndexSchedule];
            if (e == null || e.length < 2) {
                System.out.println("Día " + (dayIndexSchedule + 1) + " vacío o inválido.");
                lastOperationOK = true;
                return;
            }
            int t = e[0];
            int x = e[1];
            if (t == 1) {
                placeRobot(x);
            } else if (t == 2) {
                int c = (e.length > 2) ? e[2] : 0;
                placeStore(x, c);
            } else {
                System.out.println("Tipo de evento inválido en día " + (dayIndexSchedule + 1) + ": " + t);
            }
            System.out.println("Día " + (dayIndexSchedule + 1) + " aplicado con reboot (acumulando).");
            lastOperationOK = true;
            return;
        }

        // COMPORTAMIENTO ORIGINAL DE reboot (si no hay schedule activo)
        for (int i = 0; i < storeRefs.length; i++) {
            if (storeRefs[i] != null) {
                storeRefs[i].makeInvisible();
                storeRefs[i] = null;
                stores[i][0] = 0;
                stores[i][1] = 0;
            }
        }
        for (int i = 0; i < robotRefs.length; i++) {
            if (robotRefs[i] != null) {
                robotRefs[i].makeInvisible();
                robotRefs[i] = null;
                robots[i][0] = 0;
                robots[i][1] = 0;
            }
        }
        profit = 0;        
        maxProfit = 0;        
        updateProgressBar();
        System.out.println("SilkRoad ha sido reiniciado.");
        lastOperationOK = true;
    }

    /**
     * @return profit acumulado total.
     */
    public int profit() {        
        return profit;    
    }

    /**
     * @return matriz de tiendas (puede contener filas vacías con ceros).
     */
    public int[][] stores() {
        return stores;
    }

    /**
     * @return matriz de robots (puede contener filas vacías con ceros).
     */
    public int[][] robots() {
        return robots;
    }

    /**
     * Limpia completamente referencias, resetea profit y acumulados y oculta la vista.
     * No desactiva dayMode.
     */
    public void finish() {        
         makeInvisible();        
         Arrays.fill(storeRefs, null);        
         Arrays.fill(robotRefs, null);        
         for (int i = 0; i < stores.length; i++) {            
             stores[i][0] = 0;            
             stores[i][1] = 0;        
        }        
        for (int i = 0; i < robots.length; i++) {            
            robots[i][0] = 0;            
            robots[i][1] = 0;        
        }
        for (int i = 0; i < profitPerLocation.length; i++) {
            profitPerLocation[i][1] = 0;
        }
        profit = 0;        
        maxProfit = 0;        
        updateProgressBar();        
        lastOperationOK = true;    
    }

    /**
     * @return true si la última operación registrada fue válida.
     */
    public boolean ok() {
        return lastOperationOK;
    }
    
    /**
     * Activa un schedule (uso interno).
     * @param days matriz de eventos
     */
    private void setDaysSchedule(int[][] days) {
        this.daysSchedule = days;
        this.dayIndexSchedule = -1;
        this.dayMode = true;
        System.out.println("Schedule cargado: " + (days == null ? 0 : days.length) + " días. Usa reboot() para pasar el día.");
    }

    /**
     * Desactiva el modo día y restaura comportamiento de limpieza en reboot().
     */
    private void disableDayMode() {
        this.dayMode = false;
        System.out.println("Modo días desactivado: reboot() vuelve a reiniciar todo.");
    }

    /**
     * Encuentra la mayor ubicación presente en la matriz de eventos para dimensionar la SilkRoad.
     * @param days schedule de días (puede ser null)
     * @return mayor índice de ubicación encontrado o 0
     */
    private static int maxLocationFromDays(int[][] days) {
        int mx = 0;
        if (days != null) {
            for (int[] e : days) {
                if (e != null && e.length >= 2) {
                    mx = Math.max(mx, e[1]);
                }
            }
        }
        return mx;
    }

    /**
     * Revisa si algún robot coincide con alguna tienda y transfiere tenges.
     * Actualiza profit, profitPerLocation y la barra de progreso.
     */
    private void transferTengesIfCoincide() {
        for (int i = 0; i < robots.length; i++) {
            Robot r = robotRefs[i];
            if (r == null) continue;
    
            Store s = storeRefs[i];
            if (s != null && stores[i][1] > 0) {
                int collected = stores[i][1];   // lo que hay en la tienda
                stores[i][1] = 0;               // vaciar tienda
                robots[i][1] += collected;      // asignar al robot
                profit += collected;            // ganancia global
    
                // 👉 acumular en profitPerLocation (suma al acumulado anterior)
                profitPerLocation[i][1] += collected;
    
                System.out.println(
                    "Robot en celda " + i +
                    " recogió " + collected +
                    " → acumulado ahora: " + profitPerLocation[i][1]
                );
    
                updateProgressBar();
            }
        }
    }

    /**
     * Elimina una tienda en la ubicación dada (si existe).
     * @param location índice de la celda
     */
    public void removeStore(int location) {
        if (location < 0 || location >= stores.length) {
            System.out.println("Índice de tienda inválido: " + location);
            return;
        }
        if (storeRefs != null && storeRefs[location] != null) {
            storeRefs[location].makeInvisible();
            storeRefs[location] = null;
        }
        maxProfit -= stores[location][1]; 
        stores[location][0] = 0;
        stores[location][1] = 0;
        updateProgressBar(); 
        System.out.println("Tienda eliminada de la casilla " + location);
        lastOperationOK = true;
    }

    /**
     * Elimina un robot en la ubicación dada (si existe).
     * @param location índice de la celda
     */
    public void removeRobot(int location) {
        if (location < 0 || location >= robotRefs.length) {
            System.out.println("Índice de robot inválido: " + location);
            return;
        }
        if (robotRefs[location] != null) {
            robotRefs[location].makeInvisible();
            robotRefs[location] = null;
        }
        robots[location][0] = 0;
        robots[location][1] = 0;
        System.out.println("Robot eliminado de la casilla " + location);
        lastOperationOK = true;
    }

    /**
     * Actualiza gráficamente la barra de progreso según profit y maxProfit.
     */
    private void updateProgressBar() {
        if (progressBar != null) {
            progressBar.setProgress(profit, Math.max(1, maxProfit)); // evita división por cero
        }
    }
}
