import java.util.Scanner; // Para recibir la longitud desde el usuario
import java.util.List;
import java.util.*;

public class SilkRoad {
    private int length;                 // Longitud de la SilkRoad
    private int[][] stores;             // Matriz de tiendas {location, tenges}
    private int[][] robots;             // Matriz de robots {location, tenges}
    private int[][] positions;
    private Road road;
    private int profit;
    private boolean lastOperationOK;
    private ProgressBar progressBar;
    private boolean visible;
    private int maxProfit;
    private int tenges;
    private Robot[] robotRefs; 
    private Store[] storeRefs;
    private int[] robotOrigins;


    // Constructor que recibe la longitud del camino
    public SilkRoad(int length ) {
        this.length = length;
        this.positions = new int[length+1][2];
        this.stores = new int[length+1][2];     
        this.robots = new int[length+1][2];
        this.robotRefs = new Robot[this.positions.length];
        this.storeRefs = new Store[this.positions.length];
        this.robotOrigins = new int[length+1];
        Arrays.fill(this.robotOrigins, -1);

        this.road = new Road(length);
        int[][] roadPos = road.getPositions();
        for (int i = 0; i < roadPos.length; i++) {
            this.positions[i][0] = roadPos[i][0];
            this.positions[i][1] = roadPos[i][1];
        }
        this.progressBar = new ProgressBar(true);        
        this.profit = 0;        
        this.maxProfit = 0;
        this.visible = true;
        this.lastOperationOK = true;
    }
    
    
    public int getLength() {
        return length;
    }

    private int[][] getRobots() {
        return robots;
    }
    
    // Ordena la matriz de stores según la ubicación (location) en orden ascendente
    private void sortStores() {
        Arrays.sort(stores, (a, b) -> Integer.compare(a[0], b[0]));  // Ordena por la columna de location
    }

    // Ordena la matriz de robots según la ubicación (location) en orden ascendente
    private void sortRobots() {
        Arrays.sort(robots, (a, b) -> Integer.compare(a[0], b[0]));  // Ordena por la columna de location
    }
    
    public void setCellPosition(int index, int x, int y) {
        if (index >= 0 && index < positions.length) {
            positions[index][0] = x;
            positions[index][1] = y;
        }
    }

    
    public void placeStore(int location, int tenges) {
        if (location < 0 || location >= positions.length) {
            System.out.println("Índice de casilla inválido: " + location);
            return;
        }
        if (storeRefs[location] != null) {
            System.out.println("Ya existe una tienda en la casilla " + location);
            return;
        }
    
        // crear y registrar la tienda
        Store s = new Store(this.visible);
        storeRefs[location] = s;
    
        // guardar datos en la matriz de stores
        stores[location][0] = location;  
        stores[location][1] = tenges;
        maxProfit += tenges;
        updateProgressBar();
        
        if (this.visible && road != null) {
            road.assignStore(s);
            road.assignObjectPosition(location, "store");
            s.makeVisible();
        }
        transferTengesIfCoincide();
        System.out.println("Tienda colocada en la casilla " + location + " con " + tenges + " tenges.");
        lastOperationOK = true;
    }


    // Método para colocar el robot en la celda indicada por la location
    public void placeRobot(int location) {
        if (location < 0 || location >= positions.length) {
            System.out.println("Índice de casilla inválido: " + location);
            return;
        }
        if (robotRefs[location] != null) {
            System.out.println("Ya existe un robot en la casilla " + location);
            return;
        }
    
        // crear y registrar el robot (solo aquí)
        Robot r = new Robot(this.visible);
        robotRefs[location] = r;
    
        // actualizar la matriz de robots (si la usas para llevar info)
        robots[location][0] = location;
        robots[location][1] = 0; // tenges iniciales
        robotOrigins[location] = location;
    
        if (this.visible && road != null) {
            road.assignRobot(r);
            road.assignObjectPosition(location, "robot");
            r.makeVisible();
        }
    
        System.out.println("Robot colocado en la casilla " + location);
        transferTengesIfCoincide();
        lastOperationOK = true;
    }


    public void moveRobot(int location, int meters) {
        if (location < 0 || location >= robotRefs.length) {
            System.out.println("Índice origen inválido: " + location);
            return;
        }
        Robot r = robotRefs[location];
        if (r == null) {
            System.out.println("No hay robot en la casilla " + location);
            return;
        }
        int newLocation = location + meters;
        if (newLocation < 0 || newLocation >= robotRefs.length) {
            System.out.println("Movimiento inválido: fuera de límites.");
            return;
        }
        if (robotRefs[newLocation] != null) {
            System.out.println("Ya existe un robot en la casilla destino " + newLocation);
            return;
        }
        int tenges = robots[location][1];
        int originVal = robotOrigins[location];
        if (originVal == -1){
            originVal = location;
        }
        robotRefs[location] = null;
        robots[location][0] = 0;
        robots[location][1] = 0;
        robotRefs[newLocation] = r;
        robots[newLocation][0] = newLocation;
        robots[newLocation][1] = tenges;
        robotOrigins[newLocation] = originVal;
        
        if (this.visible && road != null) {
            road.assignRobot(r); // por seguridad, aseguramos que road conozca la instancia
            road.moveRobotVisual(location, meters, r);
        }
        
        System.out.println("Robot movido de la casilla " + location + " a la casilla " + newLocation);
        transferTengesIfCoincide();
        lastOperationOK = true;
    }

    // Método privado que revisa si algún robot coincide con alguna tienda
    // y transfiere tenges, actualizando la ProgressBar automáticamente
    private void transferTengesIfCoincide() {
        for (int i = 0; i < robotRefs.length; i++) {
            Robot r = robotRefs[i];
            if (r == null) continue;
    
            Store s = storeRefs[i];
            if (s != null && stores[i][1] > 0) {
                int collected = stores[i][1];   // Tengues a recoger
                robots[i][1] += collected;      // Sumarlos al robot
                profit += collected;            // Sumar a la ganancia total
                stores[i][1] = 0;               // Vaciar la tienda
    
                // Actualizar la barra de progreso
                updateProgressBar();
    
                System.out.println("Robot en la celda " + i + 
                    " tomó " + collected + " tenges de la tienda en la misma celda.");
            }
        }
    }

    
    private void updateProgressBar() {
        if (progressBar != null) {
            progressBar.setProgress(profit, Math.max(1, maxProfit)); // evita división por cero
        }
    }



    public void removeStore(int location) {
        if (location < 0 || location >= stores.length) {
            System.out.println("Índice de tienda inválido: " + location);
            return;
        }
        if (storeRefs != null && storeRefs[location] != null) {
            storeRefs[location].makeInvisible();
            storeRefs[location] = null;
        }
        maxProfit -= stores[location][1]; 
        stores[location][0] = 0;
        stores[location][1] = 0;
        updateProgressBar(); 
        System.out.println("Tienda eliminada de la casilla " + location);
        lastOperationOK = true;
    }


    public void removeRobot(int location) {
        if (location < 0 || location >= robotRefs.length) {
            System.out.println("Índice de robot inválido: " + location);
            return;
        }
        if (robotRefs[location] != null) {
            robotRefs[location].makeInvisible();
            robotRefs[location] = null;
        }
        robots[location][0] = 0;
        robots[location][1] = 0;
        System.out.println("Robot eliminado de la casilla " + location);
        lastOperationOK = true;
    }



    public void resupplyStores() {        
        // Reabastece todas las tiendas a 10 tenges (o el valor que desees)        
        for (int i = 0; i < stores.length; i++) {            
            if (storeRefs[i] != null) {       
                int diff = 10 - stores[i][1];                
                if (diff > 0) {                    
                    stores[i][1] = 10;                    
                    maxProfit += diff;                
                }            
            }        
        }        
        updateProgressBar();        
        System.out.println("Tiendas reabastecidas.");        
        lastOperationOK = true;    
    }

    
    public void returnRobots() {
        for (int i = 0; i < robotRefs.length; i++) {
            Robot r = robotRefs[i];
            if (r == null) continue;
    
            int originIndex = robotOrigins[i];
            if (originIndex == -1 || originIndex == i) continue;
    
            int tenges = robots[i][1];
    
            // liberar casilla actual
            robotRefs[i] = null;
            robots[i][0] = 0;
            robots[i][1] = 0;
            robotOrigins[i] = -1;
    
            // devolver al origen
            robotRefs[originIndex] = r;
            robots[originIndex][0] = originIndex;
            robots[originIndex][1] = tenges;
            robotOrigins[originIndex] = originIndex;
    
            // mover visual
            
            if (this.visible && road != null) {
                road.moveRobotVisual(i, originIndex, r);
            }
            
    
            System.out.println("Robot devuelto de " + i + " a su posición original " + originIndex);
            lastOperationOK = true;
        }
    }

    public void makeInvisible() {
        if (!visible) {
            System.out.println("SilkRoad: ya estaba invisible.");
            return;
        }
    
        // Ocultar tiendas
        if (storeRefs != null) {
            for (Store s : storeRefs) {
                if (s != null) s.makeInvisible();
            }
        }
    
        // Ocultar robots
        if (robotRefs != null) {
            for (Robot r : robotRefs) {
                if (r != null) r.makeInvisible();
            }
        }
    
        // Ocultar camino y barra
        if (road != null) road.makeInvisible();
        if (progressBar != null) progressBar.makeInvisible();
    
        visible = false;
        System.out.println("SilkRoad: ahora invisible (estado guardado, lógica activa).");
    }
    
    
    public void makeVisible() {
        if (visible) {
            System.out.println("SilkRoad: ya estaba visible, no se hace nada.");
            return;
        }
    
        // Mostrar camino
        if (road != null) road.makeVisible();
    
        // Mostrar tiendas en su última posición
        if (storeRefs != null) {
            for (int i = 0; i < storeRefs.length; i++) {
                Store s = storeRefs[i];
                if (s != null) {
                    s.makeVisible(); // usa posición actual (ya guardada en Store)
                }
            }
        }
    
        // Mostrar robots en su última posición
        if (robotRefs != null) {
            for (int i = 0; i < robotRefs.length; i++) {
                Robot r = robotRefs[i];
                if (r != null) {
                    r.makeVisible(); // usa la posición actual (ya guardada en Robot)
                }
            }
        }
    
        if (progressBar != null) progressBar.makeVisible();
    
        visible = true;
        System.out.println("SilkRoad: ahora visible (manteniendo posiciones actuales).");
    }



    public void reboot() {
        for (int i = 0; i < storeRefs.length; i++) {
            if (storeRefs[i] != null) {
                storeRefs[i].makeInvisible();
                storeRefs[i] = null;
                stores[i][0] = 0;
                stores[i][1] = 0;
            }
        }
        for (int i = 0; i < robotRefs.length; i++) {
            if (robotRefs[i] != null) {
                robotRefs[i].makeInvisible();
                robotRefs[i] = null;
                robots[i][0] = 0;
                robots[i][1] = 0;
            }
        }
        profit = 0;        
        maxProfit = 0;        
        updateProgressBar();
        System.out.println("SilkRoad ha sido reiniciado.");
        lastOperationOK = true;
    }

    public int profit() {        
        return profit;    
    }

    public int[][] stores() {
        return stores;
    }

    public int[][] robots() {
        return robots;
    }


     public void finish() {        
         makeInvisible();        
         Arrays.fill(storeRefs, null);        
         Arrays.fill(robotRefs, null);        
         for (int i = 0; i < stores.length; i++) {            
             stores[i][0] = 0;            
             stores[i][1] = 0;        
        }        
        for (int i = 0; i < robots.length; i++) {            
            robots[i][0] = 0;            
            robots[i][1] = 0;        
        }        
        profit = 0;        
        maxProfit = 0;        
        updateProgressBar();        
        lastOperationOK = true;    
    }

    public boolean ok() {
        return lastOperationOK;
    }
}
