import java.util.Scanner; // Para recibir la longitud desde el usuario
import java.util.List;
import java.util.*;

public class SilkRoad {
    private int length;                 // Longitud de la SilkRoad
    private int[][] stores;             // Matriz de tiendas {location, tenges}
    private int[][] robots;             // Matriz de robots {location, tenges}
    private int[][] positions;
    private Store store;
    private Robot robot;
    private Road road;
    private int profit;
    private boolean lastOperationOK;
    private ProgressBar progressBar;
    private boolean visible;
    private int cellSize = 50;
    private int gap = 10; // Puedes ajustar el espacio entre vueltas
    private int maxProfit;
    private int tenges;
    private int storeCount = 0;
    private int robotCount = 0;
    private Robot[] robotRefs; // referencia por casilla al robot que hay ahí (null si no hay)
    private Store[] storeRefs;


    // Constructor que recibe la longitud del camino
    public SilkRoad(int length ) {
        this.length = length;
        this.positions = new int[length+1][2];
        this.stores = new int[length+1][2];     
        this.robots = new int[length+1][2];
        // asumimos que positions ya fue creado como new int[length + 1][2]
        this.robotRefs = new Robot[this.positions.length];
        this.storeRefs = new Store[this.positions.length];

        this.road = new Road(length);
        int[][] roadPos = road.getPositions();
        for (int i = 0; i < roadPos.length; i++) {
            this.positions[i][0] = roadPos[i][0];
            this.positions[i][1] = roadPos[i][1];
        }
    }
    
    
    public int getLength() {
        return length;
    }

    private int[][] getRobots() {
        return robots;
    }
    
    // Ordena la matriz de stores según la ubicación (location) en orden ascendente
    private void sortStores() {
        Arrays.sort(stores, (a, b) -> Integer.compare(a[0], b[0]));  // Ordena por la columna de location
    }

    // Ordena la matriz de robots según la ubicación (location) en orden ascendente
    private void sortRobots() {
        Arrays.sort(robots, (a, b) -> Integer.compare(a[0], b[0]));  // Ordena por la columna de location
    }
    
    public void setCellPosition(int index, int x, int y) {
        if (index >= 0 && index < positions.length) {
            positions[index][0] = x;
            positions[index][1] = y;
        }
    }

    
    public void placeStore(int location, int tenges) {
        if (location < 0 || location >= positions.length) {
            System.out.println("Índice de casilla inválido: " + location);
            return;
        }
        if (storeRefs[location] != null) {
            System.out.println("Ya existe una tienda en la casilla " + location);
            return;
        }
    
        // crear y registrar la tienda
        Store s = new Store();
        storeRefs[location] = s;
    
        // guardar datos en la matriz de stores
        stores[location][0] = location + 1;  
        stores[location][1] = tenges;
        
        road.assignStore(s);
        // pedirle a Road que la dibuje
        road.assignObjectPosition(location, "store");
    
        System.out.println("Tienda colocada en la casilla " + location + 
                           " con " + tenges + " tenges.");
    }


    // Método para colocar el robot en la celda indicada por la location
    public void placeRobot(int location) {
        if (location < 0 || location >= positions.length) {
            System.out.println("Índice de casilla inválido: " + location);
            return;
        }
        if (robotRefs[location] != null) {
            System.out.println("Ya existe un robot en la casilla " + location);
            return;
        }
    
        // crear y registrar el robot (solo aquí)
        Robot r = new Robot();
        robotRefs[location] = r;
    
        // actualizar la matriz de robots (si la usas para llevar info)
        robots[location][0] = location+1;
        robots[location][1] = 0; // tenges iniciales
    
        // mantener compatibilidad con Road (si tu Road espera recibir la referencia)
        road.assignRobot(r);
        road.assignObjectPosition(location, "robot");
    
        System.out.println("Robot colocado en la casilla " + location);
    }


    public void moveRobot(int location, int meters) {
        if (location < 0 || location >= robotRefs.length) {
            System.out.println("Índice origen inválido: " + location);
            return;
        }
        Robot r = robotRefs[location];
        if (r == null) {
            System.out.println("No hay robot en la casilla " + location);
            return;
        }
        int newLocation = location + meters;
        if (newLocation < 0 || newLocation >= robotRefs.length) {
            System.out.println("Movimiento inválido: fuera de límites.");
            return;
        }
        if (robotRefs[newLocation] != null) {
            System.out.println("Ya existe un robot en la casilla destino " + newLocation);
            return;
        }
        robotRefs[location] = null;
        robots[location][0] = -1; // convención: -1 = sin robot
        robots[location][1] = 0;
    
        // 2. ponerlo en la casilla destino
        robotRefs[newLocation] = r;
        robots[newLocation][0] = newLocation;
        // robots[newLocation][1] conserva tenges si lo manejas ahí
    
        // 3. mover visualmente al robot
        road.moveRobotVisual(location, newLocation, r);
    
        System.out.println("Robot movido de la casilla " + location + " a la casilla " + newLocation);
    }




    // Método privado que revisa si algún robot coincide con alguna tienda
    private void transferTengesIfCoincide() {
        for (int i = 0; i < robots.length; i++) {
            int robotLocation = robots[i][0];  // Ubicación actual del robot
    
            for (int j = 0; j < stores.length; j++) {
                int storeLocation = stores[j][0];  // Ubicación de la tienda
    
                // Si coinciden en la misma celda
                if (robotLocation == storeLocation && stores[j][1] > 0) {
                    // Transferir los tenges al robot
                    robots[i][1] += stores[j][1];
    
                    // Dejar la tienda en 0
                    stores[j][1] = 0;
    
                    System.out.println("Robot en celda " + robotLocation + " tomó " +
                                       robots[i][1] + " tenges de la tienda en la misma celda.");
                }
            }
        }
    }



    public void removeStore(int location) {
        if (location < 0 || location >= stores.length) {
            System.out.println("Índice de tienda inválido: " + location);
            return;
        }
        if (storeRefs != null && storeRefs[location] != null) {
            storeRefs[location].makeInvisible();
            storeRefs[location] = null;
        }
        stores[location][0] = 0;
        stores[location][1] = 0;
        System.out.println("Tienda eliminada de la casilla " + location);
    }


    public void removeRobot(int location) {
        if (location < 0 || location >= robotRefs.length) {
            System.out.println("Índice de robot inválido: " + location);
            return;
        }
        if (robotRefs[location] != null) {
            robotRefs[location].makeInvisible();
            robotRefs[location] = null;
        }
        robots[location][0] = 0;
        robots[location][1] = 0;
        System.out.println("Robot eliminado de la casilla " + location);
    }



    public void resupplyStores() {
        // Método vacío: Implementar la lógica para reabastecer las tiendas con tenges
    }

    public void returnRobots() {
        // Método vacío: Implementar la lógica para devolver los robots a sus ubicaciones originales
    }

    public void reboot() {
        // Método vacío: Implementar la lógica para reiniciar el sistema
    }

    public int profit() {
        // Método vacío: Implementar la lógica para calcular el beneficio total
        return 0;
    }

    public int[][] stores() {
        // Método vacío: Retorna la matriz de tiendas
        return stores;
    }

    public int[][] robots() {
        // Método vacío: Retorna la matriz de robots
        return robots;
    }

    public void makeVisible() {
        // Método vacío: Implementar la lógica para hacer visible la SilkRoad
    }

    public void makeInvisible() {
        // Método vacío: Implementar la lógica para hacer invisible la SilkRoad
    }

    public void finish() {
        // Método vacío: Implementar la lógica para finalizar el proceso o la simulación
    }

    public boolean ok() {
        // Método vacío: Implementar la lógica para verificar el estado correcto
        return true;
    }
}
