import java.util.Scanner; // Para recibir la longitud desde el usuario
import java.util.List;
import java.util.*;

public class SilkRoad {
    private int length;                 // Longitud de la SilkRoad
    private int[][] stores;             // Matriz de tiendas {location, tenges}
    private int[][] robots;             // Matriz de robots {location, tenges}
    private int[][] positions;
    private Road road;
    private int profit;
    private boolean lastOperationOK;
    private ProgressBar progressBar;
    private boolean visible;
    private int maxProfit;
    private int tenges;
    private Robot[] robotRefs; 
    private Store[] storeRefs;
    private int[] robotOrigins;


    // Constructor que recibe la longitud del camino
    public SilkRoad(int length ) {
        this.length = length;
        this.positions = new int[length+1][2];
        this.stores = new int[length+1][2];     
        this.robots = new int[length+1][2];
        this.robotRefs = new Robot[this.positions.length];
        this.storeRefs = new Store[this.positions.length];
        this.robotOrigins = new int[length+1];
        Arrays.fill(this.robotOrigins, -1);

        this.road = new Road(length);
        int[][] roadPos = road.getPositions();
        for (int i = 0; i < roadPos.length; i++) {
            this.positions[i][0] = roadPos[i][0];
            this.positions[i][1] = roadPos[i][1];
        }
        this.visible = true;
    }
    
    
    public int getLength() {
        return length;
    }

    private int[][] getRobots() {
        return robots;
    }
    
    // Ordena la matriz de stores según la ubicación (location) en orden ascendente
    private void sortStores() {
        Arrays.sort(stores, (a, b) -> Integer.compare(a[0], b[0]));  // Ordena por la columna de location
    }

    // Ordena la matriz de robots según la ubicación (location) en orden ascendente
    private void sortRobots() {
        Arrays.sort(robots, (a, b) -> Integer.compare(a[0], b[0]));  // Ordena por la columna de location
    }
    
    public void setCellPosition(int index, int x, int y) {
        if (index >= 0 && index < positions.length) {
            positions[index][0] = x;
            positions[index][1] = y;
        }
    }

    
    public void placeStore(int location, int tenges) {
        if (location < 0 || location >= positions.length) {
            System.out.println("Índice de casilla inválido: " + location);
            return;
        }
        if (storeRefs[location] != null) {
            System.out.println("Ya existe una tienda en la casilla " + location);
            return;
        }
    
        // crear y registrar la tienda
        Store s = new Store(this.visible);
        storeRefs[location] = s;
    
        // guardar datos en la matriz de stores
        stores[location][0] = location;  
        stores[location][1] = tenges;
        
        if (this.visible && road != null) {
            road.assignStore(s);
            road.assignObjectPosition(location, "store");
            s.makeVisible();
        }
        
        System.out.println("Tienda colocada en la casilla " + location + " con " + tenges + " tenges.");
    }


    // Método para colocar el robot en la celda indicada por la location
    public void placeRobot(int location) {
        if (location < 0 || location >= positions.length) {
            System.out.println("Índice de casilla inválido: " + location);
            return;
        }
        if (robotRefs[location] != null) {
            System.out.println("Ya existe un robot en la casilla " + location);
            return;
        }
    
        // crear y registrar el robot (solo aquí)
        Robot r = new Robot(this.visible);
        robotRefs[location] = r;
    
        // actualizar la matriz de robots (si la usas para llevar info)
        robots[location][0] = location;
        robots[location][1] = 0; // tenges iniciales
        robotOrigins[location] = location;
    
        if (this.visible && road != null) {
            road.assignRobot(r);
            road.assignObjectPosition(location, "robot");
            r.makeVisible();
        }
    
        System.out.println("Robot colocado en la casilla " + location);
    }


    public void moveRobot(int location, int meters) {
        if (location < 0 || location >= robotRefs.length) {
            System.out.println("Índice origen inválido: " + location);
            return;
        }
        Robot r = robotRefs[location];
        if (r == null) {
            System.out.println("No hay robot en la casilla " + location);
            return;
        }
        int newLocation = location + meters;
        if (newLocation < 0 || newLocation >= robotRefs.length) {
            System.out.println("Movimiento inválido: fuera de límites.");
            return;
        }
        if (robotRefs[newLocation] != null) {
            System.out.println("Ya existe un robot en la casilla destino " + newLocation);
            return;
        }
        int tenges = robots[location][1];
        int originVal = robotOrigins[location];
        if (originVal == -1){
            originVal = location;
        }
        robotRefs[location] = null;
        robots[location][0] = 0;
        robots[location][1] = 0;
        robotRefs[newLocation] = r;
        robots[newLocation][0] = newLocation;
        robots[newLocation][1] = tenges;
        robotOrigins[newLocation] = originVal;
        
        if (this.visible && road != null) {
            road.assignRobot(r); // por seguridad, aseguramos que road conozca la instancia
            road.moveRobotVisual(location, newLocation, r);
        } else {
            
        }
        
        System.out.println("Robot movido de la casilla " + location + " a la casilla " + newLocation);
    }




    // Método privado que revisa si algún robot coincide con alguna tienda
    private void transferTengesIfCoincide() {
        for (int i = 0; i < robots.length; i++) {
            int robotLocation = robots[i][0];  // Ubicación actual del robot
    
            for (int j = 0; j < stores.length; j++) {
                int storeLocation = stores[j][0];  // Ubicación de la tienda
    
                // Si coinciden en la misma celda
                if (robotLocation == storeLocation && stores[j][1] > 0) {
                    // Transferir los tenges al robot
                    robots[i][1] += stores[j][1];
    
                    // Dejar la tienda en 0
                    stores[j][1] = 0;
    
                    System.out.println("Robot en celda " + robotLocation + " tomó " +
                                       robots[i][1] + " tenges de la tienda en la misma celda.");
                }
            }
        }
    }



    public void removeStore(int location) {
        if (location < 0 || location >= stores.length) {
            System.out.println("Índice de tienda inválido: " + location);
            return;
        }
        if (storeRefs != null && storeRefs[location] != null) {
            storeRefs[location].makeInvisible();
            storeRefs[location] = null;
        }
        stores[location][0] = 0;
        stores[location][1] = 0;
        System.out.println("Tienda eliminada de la casilla " + location);
    }


    public void removeRobot(int location) {
        if (location < 0 || location >= robotRefs.length) {
            System.out.println("Índice de robot inválido: " + location);
            return;
        }
        if (robotRefs[location] != null) {
            robotRefs[location].makeInvisible();
            robotRefs[location] = null;
        }
        robots[location][0] = 0;
        robots[location][1] = 0;
        System.out.println("Robot eliminado de la casilla " + location);
    }



    public void resupplyStores() {
        // Método vacío: Implementar la lógica para reabastecer las tiendas con tenges
    }

    
    public void returnRobots() {
        for (int i = 0; i < robotRefs.length; i++) {
            Robot r = robotRefs[i];
            if (r == null) continue;
    
            int originIndex = robotOrigins[i];
            if (originIndex == -1 || originIndex == i) continue;
    
            int tenges = robots[i][1];
    
            // liberar casilla actual
            robotRefs[i] = null;
            robots[i][0] = 0;
            robots[i][1] = 0;
            robotOrigins[i] = -1;
    
            // devolver al origen
            robotRefs[originIndex] = r;
            robots[originIndex][0] = originIndex;
            robots[originIndex][1] = tenges;
            robotOrigins[originIndex] = originIndex;
    
            // mover visual
            
            if (this.visible && road != null) {
                road.moveRobotVisual(i, originIndex, r);
            }
            
    
            System.out.println("Robot devuelto de " + i + " a su posición original " + originIndex);
        }
    }

    // SilkRoad.java
    public void makeInvisible() {
        if (storeRefs != null) {
            for (Store s : storeRefs) {
                if (s != null) s.makeInvisible();
            }
        }
    
        if (robotRefs != null) {
            for (Robot r : robotRefs) {
                if (r != null) r.makeInvisible();
            }
        }
    
        if (road != null) road.makeInvisible();
    
        visible = false;
        System.out.println("SilkRoad: ahora invisible (solo lógica activa).");
    }


    
    public void makeVisible() {
        if (road != null) road.makeVisible();
    
        if (storeRefs != null) {
            for (int i = 0; i < storeRefs.length; i++) {
                Store s = storeRefs[i];
                if (s != null) {
                    s.makeVisible();
                    road.assignStore(s);
                    road.assignObjectPosition(i, "store");
                }
            }
        }
    
        if (robotRefs != null) {
            for (int i = 0; i < robotRefs.length; i++) {
                Robot r = robotRefs[i];
                if (r != null) {
                    r.makeVisible();
                    road.assignRobot(r);
                    road.moveRobotVisual(i, i, r); // Redibuja en la celda actual
                }
            }
        }
    
        visible = true;
        System.out.println("SilkRoad: ahora visible y sincronizado.");
    }






    public void reboot() {
        for (int i = 0; i < storeRefs.length; i++) {
            if (storeRefs[i] != null) {
                storeRefs[i].makeInvisible();
                storeRefs[i] = null;
                stores[i][0] = 0;
                stores[i][1] = 0;
            }
        }
        for (int i = 0; i < robotRefs.length; i++) {
            if (robotRefs[i] != null) {
                robotRefs[i].makeInvisible();
                robotRefs[i] = null;
                robots[i][0] = 0;
                robots[i][1] = 0;
            }
        }
        profit = 0;
        System.out.println("SilkRoad ha sido reiniciado.");
    }

    public int profit() {
        // Método vacío: Implementar la lógica para calcular el beneficio total
        return 0;
    }

    public int[][] stores() {
        // Método vacío: Retorna la matriz de tiendas
        return stores;
    }

    public int[][] robots() {
        // Método vacío: Retorna la matriz de robots
        return robots;
    }


    public void finish() {
        // Método vacío: Implementar la lógica para finalizar el proceso o la simulación
    }

    public boolean ok() {
        // Método vacío: Implementar la lógica para verificar el estado correcto
        return true;
    }
}
