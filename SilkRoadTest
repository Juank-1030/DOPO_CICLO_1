import static org.junit.Assert.*;
import org.junit.Test;

/**
 * Pruebas unitarias (JUnit 4) para la clase SilkRoad.
 *
 * Objetivo: verificar el comportamiento público sin modificar la lógica interna.
 * - Se cubren constructores, colocación y eliminación de robots y tiendas.
 * - Transferencia de tenges (profit).
 * - Movimiento individual y automático (moveRobots).
 * - Reabastecimiento, vaciado de tiendas, retorno de robots.
 * - Modo día (schedule) vs modo normal en reboot().
 * - finish() y bandera ok().
 *
 * NOTA: Este archivo añade SOLO documentación y comentarios. No se cambia nada del código existente.
 */
public class SilkRoadTest {

    // ---------- Helpers ----------
    /**
     * Cuenta robots "activos" en la matriz robots.
     * Se consideran filas con algún dato distinto de cero.
     * IMPORTANTE: La lógica original mezcla condiciones con '||' y '&&' sin paréntesis.
     * No se modifica para respetar tu pedido de no cambiar código.
     *
     * @param robots matriz devuelta por SilkRoad.robots()
     * @return número estimado de robots (heurístico simple)
     */
    private int countRobots(int[][] robots) {
        int c = 0;
        for (int[] r : robots) {
            // La expresión original puede producir conteos no triviales por su precedencia.
            // Se conserva tal cual.
            if (r != null && r.length >= 2 && r[0] != 0 || (r[0]==0 && r[1]>0)) {
                // Revisión adicional: si alguno de los dos valores es != 0
                if (r[0] != 0 || r[1] != 0) c++;
            }
        }
        return c;
    }

    /**
     * Cuenta tiendas activas (filas con algún valor distinto de cero).
     * @param stores matriz stores() de SilkRoad
     * @return cantidad aproximada de tiendas colocadas
     */
    private int countStores(int[][] stores) {
        int c = 0;
        for (int[] s : stores) {
            if (s != null && s.length >= 2 && (s[0] != 0 || s[1] != 0)) {
                c++;
            }
        }
        return c;
    }

    /**
     * Verifica si existe una tienda exactamente en la ubicación y con el valor esperado.
     * @param stores matriz de tiendas
     * @param loc ubicación a revisar
     * @param tenges valor esperado
     * @return true si coincide
     */
    private boolean hasStoreAt(int[][] stores, int loc, int tenges) {
        if (loc >= 0 && loc < stores.length) {
            return stores[loc][0] == loc && stores[loc][1] == tenges;
        }
        return false;
    }

    /**
     * Verifica si hay un robot en una ubicación (usando la convención robots[loc][0]==loc).
     * @param robots matriz de robots
     * @param loc ubicación
     * @return true si se considera que hay robot
     */
    private boolean hasRobotAt(int[][] robots, int loc) {
        if (loc >= 0 && loc < robots.length) {
            return robots[loc][0] == loc;
        }
        return false;
    }

    // ---------- Tests ----------

    /**
     * Verifica estado inicial con constructor por longitud.
     */
    @Test
    public void testConstructorLength() {
        SilkRoad sr = new SilkRoad(20);
        assertEquals(20, sr.getLength());
        assertEquals(0, sr.profit());
        assertTrue(sr.ok());
        assertEquals(0, countRobots(sr.robots()));
        assertEquals(0, countStores(sr.stores()));
    }

    /**
     * Verifica que el constructor con days no coloca nada hasta usar reboot().
     */
    @Test
    public void testConstructorDays_NoInitialPlacement() {
        int[][] days = { {1,5}, {2,10,30} };
        SilkRoad sr = new SilkRoad(days);
        // Antes de cualquier reboot no debe haber robots ni tiendas
        assertFalse(hasRobotAt(sr.robots(), 5));
        assertFalse(hasStoreAt(sr.stores(), 10, 30));
        sr.reboot(); // día 1: robot 5
        assertTrue(hasRobotAt(sr.robots(), 5));
        sr.reboot(); // día 2: tienda 10 con 30
        assertTrue(hasStoreAt(sr.stores(), 10, 30));
    }

    /**
     * Colocar tienda y luego robot en la misma celda debe transferir los tenges.
     */
    @Test
    public void testPlaceStoreThenRobot_ImmediateTransfer() {
        SilkRoad sr = new SilkRoad(30);
        sr.placeStore(10, 40);
        assertTrue(hasStoreAt(sr.stores(), 10, 40));
        sr.placeRobot(10); // debe vaciar y transferir
        assertTrue(hasRobotAt(sr.robots(), 10));
        assertEquals(0, sr.stores()[10][1]); // tienda vacía
        assertEquals(40, sr.profit());       // profit incrementado
    }

    /**
     * Colocar robot y luego tienda en misma celda también transfiere inmediatamente.
     */
    @Test
    public void testPlaceRobotThenStore_ImmediateTransfer() {
        SilkRoad sr = new SilkRoad(30);
        sr.placeRobot(12);
        assertTrue(hasRobotAt(sr.robots(), 12));
        sr.placeStore(12, 25); // debe transferir
        assertEquals(0, sr.stores()[12][1]);
        assertEquals(25, sr.profit());
    }

    /**
     * Eliminación de tienda y robot debe limpiar sus registros.
     */
    @Test
    public void testRemoveStoreAndRobot() {
        SilkRoad sr = new SilkRoad(30);
        sr.placeStore(8, 15);
        sr.placeRobot(5);
        sr.removeStore(8);
        assertEquals(0, sr.stores()[8][0]);
        assertEquals(0, sr.stores()[8][1]);
        sr.removeRobot(5);
        assertEquals(0, sr.robots()[5][0]);
        assertEquals(0, sr.robots()[5][1]);
    }

    /**
     * Verifica movimiento básico de robot entre celdas usando moveRobot().
     */
    @Test
    public void testMoveRobot() {
        SilkRoad sr = new SilkRoad(30);
        sr.placeRobot(3);
        sr.moveRobot(3, 5); // al 8
        assertFalse(hasRobotAt(sr.robots(), 3));
        assertTrue(hasRobotAt(sr.robots(), 8));
    }

    /**
     * Verifica estrategia de moveRobots() eligiendo la tienda más cercana.
     */
    @Test
    public void testMoveRobotsChoosesClosestPair() {
        SilkRoad sr = new SilkRoad(50);
        sr.placeRobot(2);
        sr.placeRobot(20);
        sr.placeStore(5, 10);   // Distancia 3 para robot en 2
        sr.placeStore(25, 40);  // Distancia 5 para robot en 20
        sr.moveRobots();        // Debe mover robot de 2 a 5
        assertTrue(hasRobotAt(sr.robots(), 5));
        assertEquals(0, sr.stores()[5][1]);  // vacía
        assertEquals(10, sr.profit());       // Solo recogió la de 10
    }

    /**
     * Verifica reabastecimiento de tiendas existentes a valor 10.
     */
    @Test
    public void testResupplyStores() {
        SilkRoad sr = new SilkRoad(20);
        sr.placeStore(4, 5);
        sr.placeStore(6, 0);
        sr.resupplyStores();
        assertEquals(10, sr.stores()[4][1]);
        assertEquals(10, sr.stores()[6][1]);
    }

    /**
     * Verifica retorno de robots a su posición original tras haber sido movidos.
     */
    @Test
    public void testReturnRobots() {
        SilkRoad sr = new SilkRoad(30);
        sr.placeRobot(4);
        sr.moveRobot(4, 6); // al 10
        sr.returnRobots();
        assertTrue(hasRobotAt(sr.robots(), 4));
        assertFalse(hasRobotAt(sr.robots(), 10));
    }

    /**
     * Verifica listado de tiendas vacías devuelto por emptiedStores().
     */
    @Test
    public void testEmptiedStores() {
        SilkRoad sr = new SilkRoad(30);
        sr.placeStore(9, 10);
        sr.placeRobot(9); // vacía
        sr.placeStore(15, 5);
        sr.placeRobot(15); // vacía
        int[][] emptied = sr.emptiedStores();
        boolean nine = false, fifteen = false;
        for (int[] row : emptied) {
            if (row[0] == 9 && row[1] == 0) nine = true;
            if (row[0] == 15 && row[1] == 0) fifteen = true;
        }
        assertTrue(nine && fifteen);
    }

    /**
     * Verifica avance de días en modo dayMode sin limpiar estado previo.
     */
    @Test
    public void testRebootDayMode() {
        int[][] days = { {1,3}, {2,10,50}, {1,5} };
        SilkRoad sr = new SilkRoad(days);
        sr.reboot(); // día 1 robot 3
        assertTrue(hasRobotAt(sr.robots(), 3));
        sr.reboot(); // día 2 tienda 10
        assertTrue(hasStoreAt(sr.stores(), 10, 50));
        sr.reboot(); // día 3 robot 5
        assertTrue(hasRobotAt(sr.robots(), 5));
        sr.reboot(); // ya no hay más días (no debe alterar lo existente)
        assertTrue(hasRobotAt(sr.robots(), 3));
        assertTrue(hasRobotAt(sr.robots(), 5));
    }

    /**
     * Verifica el comportamiento de reboot() en modo normal (borrado completo).
     */
    @Test
    public void testRebootNormalMode() {
        SilkRoad sr = new SilkRoad(20);
        sr.placeStore(4, 10);
        sr.placeRobot(4); // recoge
        assertEquals(10, sr.profit());
        sr.reboot(); // sin dayMode => limpia
        assertEquals(0, sr.profit());
        assertEquals(0, countRobots(sr.robots()));
        assertEquals(0, countStores(sr.stores()));
    }

    /**
     * Verifica finish(): limpieza total de estado y profit.
     */
    @Test
    public void testFinish() {
        SilkRoad sr = new SilkRoad(25);
        sr.placeStore(2, 5);
        sr.placeRobot(2);
        sr.placeStore(10, 7);
        sr.finish();
        assertEquals(0, sr.profit());
        assertEquals(0, countStores(sr.stores()));
        assertEquals(0, countRobots(sr.robots()));
    }

    /**
     * Operaciones inválidas (índices fuera de rango) no deben romper el estado básico.
     */
    @Test
    public void testInvalidOperationsDoNotThrow() {
        SilkRoad sr = new SilkRoad(10);
        sr.placeRobot(50); // fuera de rango
        sr.placeStore(-3, 5); // fuera de rango
        assertEquals(0, sr.profit());
        assertEquals(0, countStores(sr.stores()));
        assertEquals(0, countRobots(sr.robots()));
    }

    /**
     * Verifica que ok() permanezca true después de operaciones válidas encadenadas.
     */
    @Test
    public void testOkFlagAfterValidOps() {
        SilkRoad sr = new SilkRoad(15);
        sr.placeStore(5, 10);
        assertTrue(sr.ok());
        sr.placeRobot(5);
        assertTrue(sr.ok());
        sr.moveRobot(5, 3);
        assertTrue(sr.ok());
    }
}
