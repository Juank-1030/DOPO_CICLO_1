/**
 * La clase {@code Cell} representa una celda dentro del tablero del juego de canicas.
 * Cada celda puede contener:
 * <ul>
 *   <li>Un color base (usado si es un agujero).</li>
 *   <li>Un agujero donde puede caer una canica.</li>
 *   <li>Una canica (de un color espec√≠fico), si la celda no est√° vac√≠a.</li>
 * </ul>
 * Adem√°s, la celda incluye elementos gr√°ficos (rect√°ngulos y c√≠rculos) que permiten
 * representarla visualmente dentro de la interfaz del juego.
 *
 * <p>Funciones principales:</p>
 * <ul>
 *   <li>Mantener el estado l√≥gico (color, agujero, canica).</li>
 *   <li>Dibujar y mover la celda y sus componentes gr√°ficos.</li>
 *   <li>Gestionar entrada y salida de canicas.</li>
 *   <li>Verificar si la celda est√° en un estado correcto (seg√∫n el color esperado).</li>
 * </ul>
 */
public class Cell {
    private String color;          // Color de la celda
    private boolean hole;          // Indica si hay agujero
    private String marbleColor;    // Color de la canica (null si no hay)

    private int positionX;     
    private int positionY;     

    private Rectangle background; 
    private Rectangle cell;       
    private Circle holeShape;
    private Circle marbleShape;

    /**
     * Construye una celda en el tablero.
     *
     * @param color color esperado de la canica (si la celda es un agujero).
     * @param hole  {@code true} si la celda contiene un agujero, {@code false} en caso contrario.
     *              Si no es agujero, el color se fuerza siempre a blanco.
     */
    public Cell(String color, boolean hole) {
        this.color = color;
        this.hole = hole;
        this.marbleColor = null; // Por defecto, sin canica

        this.positionX = 0; 
        this.positionY = 0;
        

        // 1Ô∏è‚É£ Fondo
        background = new Rectangle();
        background.changeColor("black");
        background.changeSize(50, 50);
        background.setPosition(positionX, positionY);
        background.makeVisible();
        
        // üîπ Si no hay hueco, el color de la celda ser√° blanco SIEMPRE
        if (hole == false) {
            this.color = "white";
        } else {
            this.color = color; // el color de la canica correcta
        }

        // 2Ô∏è‚É£ Celda
        cell = new Rectangle();
        cell.changeColor(hole ? this.color : "white");
        cell.changeSize(40, 40);
        cell.setPosition(5, 5);
        cell.makeVisible();

        // 3Ô∏è‚É£ Agujero (si aplica)
        if (hole) {
            holeShape = new Circle();
            holeShape.changeColor("white");
            holeShape.changeSize(30);
            holeShape.setPosition(10, 10);
            holeShape.makeVisible();
        }
    }
    
    /**
     * Verifica si la celda contiene un agujero.
     *
     * @return {@code true} si la celda es un agujero, {@code false} en caso contrario.
     */
    public boolean hasHole() {
        return hole;
    }
    
    /**
     * Inserta una canica en la celda.
     * Si ya hab√≠a una, se sobrescribe.
     *
     * @param marbleColor color de la canica que entra.
     */
    public void in(String marbleColor) {
        this.marbleColor = marbleColor;

        // Dibujar la canica
        if (marbleShape == null) {
            marbleShape = new Circle();
            marbleShape.changeSize(20);
            marbleShape.setPosition(positionX + 15, positionY + 15);
        }
        marbleShape.changeColor(marbleColor);
        marbleShape.makeVisible();
    }
    
    /**
     * Obtiene el color de la canica en la celda.
     *
     * @return color de la canica, o {@code null} si la celda est√° vac√≠a.
     */
    public String getMarbleColor() {
        return this.marbleColor;
    }

    /**
     * Extrae la canica de la celda (si no hay agujero).
     *
     * @return el color de la canica extra√≠da, 
     *         o cadena vac√≠a si no hab√≠a canica o la celda es un agujero.
     */
    public String out() {
        if (this.marbleColor != null) {
            if (!hole) { 
                String color = this.marbleColor;
                this.marbleColor = null;
                if (marbleShape != null) marbleShape.makeInvisible();
                return color;
            } else {
                // Si hay agujero, la canica queda atrapada
                return "";
            }
        }
        return ""; // No hab√≠a canica
    }
    
    /**
     * Verifica si la celda est√° en estado correcto:
     * <ul>
     *   <li>Si no hay agujero ‚Üí siempre correcto.</li>
     *   <li>Si hay agujero vac√≠o ‚Üí correcto.</li>
     *   <li>Si hay agujero con canica ‚Üí correcto solo si el color coincide.</li>
     * </ul>
     *
     * @return {@code true} si la celda est√° correcta, {@code false} en caso contrario.
     */
    public boolean isOK() {
        if (!hole) {
            // ‚úÖ No hay agujero ‚Üí siempre correcto
            return true;
        }
    
        if (marbleColor == null) {
            // ‚úÖ Agujero vac√≠o ‚Üí correcto
            return true;
        }
    
        // ‚ö†Ô∏è Agujero ocupado ‚Üí verificamos color
        return marbleColor.equals(color);
    }
    
    /**
     * Indica si la celda contiene actualmente una canica.
     *
     * @return {@code true} si hay canica, {@code false} en caso contrario.
     */
    public boolean hasMarble() {
        return marbleColor != null;
    }
    
    /**
     * Mueve la celda (y todos sus elementos gr√°ficos) en una direcci√≥n dada.
     *
     * @param direction direcci√≥n a mover: "up", "down", "left" o "right".
     */
    public void moveTo(String direction) {
        int step = 45; // tama√±o de la casilla en p√≠xeles
        int dx = 0;
        int dy = 0;
    
        switch (direction.toLowerCase()) {
            case "up":    dy = -step; break;
            case "down":  dy = step;  break;
            case "left":  dx = -step; break;
            case "right": dx = step;  break;
            default:
                System.out.println("Direcci√≥n no v√°lida. Usa: up, down, left, right");
                return;
        }
    
        // üîπ Actualizar posiciones l√≥gicas
        positionX += dx;
        positionY += dy;
    
        // üîπ Mover representaciones gr√°ficas
        background.moveHorizontal(dx);
        background.moveVertical(dy);
    
        cell.moveHorizontal(dx);
        cell.moveVertical(dy);
    
        if (holeShape != null) {
            holeShape.moveHorizontal(dx);
            holeShape.moveVertical(dy);
        }
    
        if (marbleShape != null) {
            marbleShape.moveHorizontal(dx);
            marbleShape.moveVertical(dy);
        }
    }
    
    /**
     * Hace visible gr√°ficamente la celda (fondo, celda, agujero y canica si existen).
     */
    public void makeVisible() {
        background.makeVisible();
        cell.makeVisible();
        
        if (holeShape != null) {
            holeShape.makeVisible();
        }
        
        if (marbleShape != null) {
            marbleShape.makeVisible();
        }
    }

    /**
     * Hace invisible gr√°ficamente la celda (fondo, celda, agujero y canica si existen).
     */
    public void makeInvisible() {
        background.makeInvisible();
        cell.makeInvisible();
        
        if (holeShape != null) {
            holeShape.makeInvisible();
        }
        
        if (marbleShape != null) {
            marbleShape.makeInvisible();
        }
    }
    
    /**
     * Devuelve la posici√≥n X de la celda.
     *
     * @return posici√≥n X en el tablero.
     */
     public int getPositionX() {
        return positionX;
    }
    
    /**
     * Devuelve la posici√≥n Y de la celda.
     *
     * @return posici√≥n Y en el tablero.
     */
    public int getPositionY() {
        return positionY;
    }
    
    /**
     * Devuelve el color esperado de la celda (usado si es agujero).
     *
     * @return color asociado a la celda.
     */
    public String getColor() {
        return color;
    }

    /**
     * Reubica la celda en coordenadas absolutas nuevas.
     * Esto mueve todos los elementos gr√°ficos asociados.
     *
     * @param x nueva coordenada X.
     * @param y nueva coordenada Y.
     */
    public void setPosition(int x, int y) {
        int dx = x - this.positionX;
        int dy = y - this.positionY;

        this.positionX = x;
        this.positionY = y;

        // Mover todo gr√°ficamente
        background.moveHorizontal(dx);
        background.moveVertical(dy);

        cell.moveHorizontal(dx);
        cell.moveVertical(dy);

        if (holeShape != null) {
            holeShape.moveHorizontal(dx);
            holeShape.moveVertical(dy);
        }

        if (marbleShape != null) {
            marbleShape.moveHorizontal(dx);
            marbleShape.moveVertical(dy);
        }
    }

}
