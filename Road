public class Road {
    private SilkRoad silkRoad;     // Referencia a la clase SilkRoad
    private Cell[] roadCells;      // Array de celdas (representa el camino)

    private int canvasWidth;  // Ancho del Canvas
    private int canvasHeight; // Alto del Canvas

    // Constructor
    public Road(SilkRoad silkRoad) {
        this.silkRoad = silkRoad;  // Recibimos la instancia de SilkRoad

        // Obtener las dimensiones del canvas desde la clase Canvas
        Canvas canvas = Canvas.getCanvas();
        this.canvasWidth = canvas.getSizeCanvasW();
        this.canvasHeight = canvas.getSizeCanvasH();

        this.roadCells = new Cell[silkRoad.getLength()];  // Inicializamos el array de celdas
    }

    // Método para generar el camino visualmente en espiral
    public void generateRoad() {
        int positionX = 0;  // Posición inicial X
        int positionY = 0;  // Posición inicial Y
        int step = 45;      // Espacio entre las celdas
        int direction = 0;  // Dirección inicial (0=derecha, 1=abajo, 2=izquierda, 3=arriba)

        // Variables para controlar los límites del canvas
        int rightLimit = canvasWidth - step;   // Límite derecho del canvas
        int bottomLimit = canvasHeight - step; // Límite inferior del canvas
        int leftLimit = 0; // Límite izquierdo
        int topLimit = 0;  // Límite superior

        // Generación del camino espiral
        for (int i = 0; i < silkRoad.getLength(); i++) {
            // Instanciamos la celda y la añadimos al array de celdas
            roadCells[i] = new Cell();
            roadCells[i].setPosition(positionX, positionY);

            // Colocamos un robot o tienda si es necesario
            if (silkRoad.getRobots()[i][0] != 0) {
                roadCells[i].placeRobot();  // Si la matriz tiene un robot, lo colocamos
            }
            if (silkRoad.getStores()[i][0] != 0) {
                roadCells[i].placeStore();  // Si la matriz tiene una tienda, la colocamos
            }

            // Hacemos visible la celda
            roadCells[i].makeVisible();

            // Cambiar dirección cuando alcanzamos un límite
            if (direction == 0 && positionX < rightLimit) {  // Mover a la derecha
                positionX += step;
            } else if (direction == 1 && positionY < bottomLimit) {  // Mover hacia abajo
                positionY += step;
            } else if (direction == 2 && positionX > leftLimit) {  // Mover a la izquierda
                positionX -= step;
            } else if (direction == 3 && positionY > topLimit) {  // Mover hacia arriba
                positionY -= step;
            }

            // Cambiar dirección cuando sea necesario
            if (positionX >= rightLimit || positionX <= leftLimit) {
                direction = (direction + 1) % 4;  // Cambiar la dirección (derecha -> abajo -> izquierda -> arriba)
                rightLimit -= step;  // Reducir el límite derecho
                leftLimit += step;  // Aumentar el límite izquierdo
            }
            if (positionY >= bottomLimit || positionY <= topLimit) {
                direction = (direction + 1) % 4;  // Cambiar la dirección (abajo -> izquierda -> arriba -> derecha)
                bottomLimit -= step;  // Reducir el límite inferior
                topLimit += step;  // Aumentar el límite superior
            }
        }
    }
}
