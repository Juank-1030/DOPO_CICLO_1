import java.util.*;

/**
 * Road representa el tablero (camino) donde se disponen las celdas en forma de espiral.
 * Mantiene:
 * <ul>
 *   <li>Lista de celdas gráficas (cells)</li>
 *   <li>Matriz de posiciones (positions) con coordenadas (x,y) para cada índice</li>
 *   <li>Referencias reutilizables a un único {@link Robot} y una única {@link Store} para posicionarlos visualmente</li>
 *   <li>Control de visibilidad general</li>
 * </ul>
 * Las celdas se crean inmediatamente en el constructor mediante drawSpiral().
 */
public class Road {
    private ArrayList<Cell> cells;
    private int length;
    private int[][] positions;
    private Robot robot;
    private Store store;
    private boolean visible;    

    /**
     * Construye el camino y dibuja inmediatamente una espiral de celdas.
     * @param length número lógico de celdas (se usa length+1 internamente)
     */
    public Road(int length) {
        this.cells = new ArrayList<>();
        this.length = length + 1;
        this.positions = new int[this.length][2];
        this.visible = true;
        drawSpiral();
    }

    /**
     * Dibuja una espiral rectangular aproximada sobre el canvas, almacenando
     * las posiciones (x,y) de cada celda en la matriz positions.
     * No retorna valor; rellena {@code cells} y {@code positions}.
     */
    public void drawSpiral() {
        Canvas canvas = Canvas.getCanvas();
        int canvasWidth = canvas.getSizeCanvasW();
        int canvasHeight = canvas.getSizeCanvasH();
    
        int cellSize = 15;
        int gap = 31;
    
        int step = cellSize + gap;
        int x0 = gap, y0 = gap;
    
        int maxCols = (canvasWidth - 2*gap) / step;
        int maxRows = (canvasHeight - gap) / step;
    
        int left = 1, top = 0;
        int right = maxCols - 1, bottom = maxRows - 1;
        int i = 0;
    
        while (i < length && left <= right && top <= bottom) {
            // Franja superior (izquierda -> derecha)
            for (int col = left - 1; col <= right && i < length; col++) {
                int x = x0 + col * step;
                int y = y0 + top * step;
                addCell(x, y);
                cellPosition(i, x, y);
                i++;
            }
            top += 2;
    
            // Columna derecha (arriba -> abajo)
            for (int row = top - 1; row <= bottom && i < length; row++) {
                int x = x0 + right * step;
                int y = y0 + row * step;
                addCell(x, y);
                cellPosition(i, x, y);
                i++;
            }
            right -= 2;
    
            // Franja inferior (derecha -> izquierda)
            for (int col = right + 1; col >= left && i < length; col--) {
                int x = x0 + col * step;
                int y = y0 + bottom * step;
                addCell(x, y);
                cellPosition(i, x, y);
                i++;
            }
            bottom -= 2;
    
            // Columna izquierda (abajo -> arriba)
            for (int row = bottom + 1; row >= top && i < length; row--) {
                int x = x0 + left * step;
                int y = y0 + row * step;
                addCell(x, y);
                cellPosition(i, x, y);
                i++;
            }
            left += 2;
        }
    }

    /**
     * Posiciona visualmente la instancia reutilizable de store o robot en la celda indicada.
     * Calcula offset relativo según la primera celda para mantener consistencia visual.
     * @param location índice lógico de la celda
     * @param objectType "store" o "robot"
     */
    public void assignObjectPosition(int location, String objectType) {
        int cellX = positions[location][0];
        int cellY = positions[location][1];
        
        System.out.println("Assigning  object: " + objectType + " to location " + location + " -> x: " + cellX + ", y: " + cellY);
    
        if (objectType.equals("store")) {
            if (store == null) store = new Store(visible);
            int offsetX = store.getX() - 30;
            int offsetY = store.getY() - 30;
            int storeX = cellX + offsetX;
            int storeY = cellY + offsetY;
            store.moveTo(storeX, storeY);
        } else if (objectType.equals("robot")) {
            if (robot == null) robot = new Robot(visible);
            int offsetX = robot.getX() - 30;
            int offsetY = robot.getY() - 30;
            int robotX = cellX + offsetX;
            int robotY = cellY + offsetY;
            robot.moveTo(robotX, robotY);
        }
    }

    /**
     * Mueve visualmente el robot desde una ubicación antigua a otra nueva.
     * @param oldLocation índice antiguo (no necesariamente usado para animación en este enfoque)
     * @param newLocation índice de destino
     * @param robot instancia de robot a mover (puede ser la interna)
     */
    public void moveRobotVisual(int oldLocation, int newLocation, Robot robot) {
        if (robot == null) return;
        if (newLocation < 0 || newLocation >= positions.length) {
            System.out.println("Movimiento inválido: fuera de límites.");
            return;
        }
    
        int cellX = positions[newLocation][0];
        int cellY = positions[newLocation][1];
        
        int offsetX = robot.getX() - 30;
        int offsetY = robot.getY() - 30;
        
        int targetX = cellX + offsetX;
        int targetY = cellY + offsetY;
    
        System.out.println("Moviendo robot a celda " + newLocation + " -> (" + targetX + "," + targetY + ")");
        robot.moveTo(targetX, targetY);
    }

    /**
     * Crea y agrega una nueva celda a la lista, la posiciona y la vuelve visible.
     * @param px coordenada X
     * @param py coordenada Y
     */
    private void addCell(int px, int py) {
        Cell cell = new Cell();
        cell.setPosition(px, py);
        cell.makeVisible();
        cells.add(cell);
    }

    /**
     * Guarda la posición (x,y) de una celda en el arreglo positions.
     * @param index índice lógico
     * @param x coordenada X
     * @param y coordenada Y
     */
    private void cellPosition(int index, int x, int y) {
        if (index >= 0 && index < positions.length) {
            positions[index][0] = x;
            positions[index][1] = y;
        }
    }

    /**
     * @return lista de celdas creadas (referencias gráficas).
     */
    public ArrayList<Cell> getCells() {
        return cells;
    }

    /**
     * @return matriz de posiciones (x,y) por índice.
     */
    public int[][] getPositions() {
        return positions;
    }
    
    /**
     * Retorna una cadena con info de coordenadas de la celda indicada.
     * @param index índice de celda
     * @return String con (X,Y) o mensaje de error si fuera de rango
     */
    public String getCellInfo(int index) {
        if (index >= 0 && index < length) {
            int x = positions[index][0];
            int y = positions[index][1];
            return "Casilla " + index + ": Coordenadas (X, Y) = (" + x + ", " + y + ")";
        }
        return "Índice fuera de rango";
    }

    /**
     * @param index índice de celda
     * @return coordenada X o -1 si fuera de rango
     */
    public int getCellX(int index) {
        if (index >= 0 && index < length) {
            return positions[index][0];
        }
        return -1;
    }

    /**
     * @param index índice de celda
     * @return coordenada Y o -1 si fuera de rango
     */
    public int getCellY(int index) {
        if (index >= 0 && index < length) {
            return positions[index][1];
        }
        return -1;
    }
    
    /**
     * Hace visibles celdas, store y robot si existen.
     */
    public void makeVisible() {
        visible = true;
        if (cells != null) {
            for (Cell c : cells) {
                if (c != null) {
                    c.makeVisible();
                }
            }
        }
        if (store != null) {
            store.makeVisible();
        }
        if (robot != null) {
            robot.makeVisible();
        }
    }
    
    /**
     * Hace invisibles celdas, store y robot (si existen).
     */
    public void makeInvisible() {
        visible = false;
        if (robot != null) {
            robot.makeInvisible();
        }
        if (store != null) {
            store.makeInvisible();
        }
        if (cells != null) {
            for (Cell c : cells) {
                if (c != null) {
                    c.makeInvisible();
                }
            }
        }
    }

    /**
     * Asocia una instancia de Store global para reubicarla en celdas.
     * @param store instancia a asignar
     */
    public void assignStore(Store store) {
        this.store = store;
    }

    /**
     * Asocia una instancia de Robot global para reubicarla en celdas.
     * @param robot instancia a asignar
     */
    public void assignRobot(Robot robot) {
        this.robot = robot;
    }
}
